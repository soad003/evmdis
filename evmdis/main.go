package main

import (
	"flag"
	"fmt"
	"github.com/soad003/evmdis"
	"io/ioutil"
	"log"
	"math/big"
	"os"
    "encoding/hex"
    "strconv"
)

const swarmHashLength = 43

var swarmHashProgramTrailer = [...]byte{0x00, 0x29}
var swarmHashHeader = [...]byte{0xa1, 0x65}

var ERC20 = [...]string{
						"dd62ed3e",  //"dd62ed3e": "allowance(address,address)", dec:3714247998
						"095ea7b3",  //"095ea7b3": "approve(address,uint256)", dec: 157198259
						"70a08231",  //"70a08231": "balanceOf(address)", dec: 1889567281
						"18160ddd",  //"18160ddd": "totalSupply()", dec: 404098525
						"a9059cbb",  //"a9059cbb": "transfer(address,uint256)", dec: 2835717307
						"23b872dd"}   //"23b872dd": "transferFrom(address,address,uint256)", dec: 599290589

var ERC223 = [...]string{
						 "70a08231", //"70a08231": "balanceOf(address)",
						 "313ce567", //"313ce567": "decimals()",
						 "06fdde03", //"06fdde03": "name()",
						 "95d89b41", //"95d89b41": "symbol()",
						 "18160ddd", //"18160ddd": "totalSupply()",
						 "a9059cbb", //"a9059cbb": "transfer(address,uint256)",
						 "be45fd62", //"be45fd62": "transfer(address,uint256,bytes)",
						 "f6368f8a"} //"f6368f8a": "transfer(address,uint256,bytes,string)"

var ERC677 = [...]string{
    "66188463", //: "decreaseApproval(address,uint256)",
    "dd62ed3e", //: "allowance(address,address)",
    "095ea7b3", //: "approve(address,uint256)",
    "70a08231", //: "balanceOf(address)",
    "313ce567", //: "decimals()",
    "d73dd623", //: "increaseApproval(address,uint256)",
    "06fdde03", //: "name()",
    "95d89b41", //: "symbol()",
    "18160ddd", //: "totalSupply()",
    "a9059cbb", //: "transfer(address,uint256)",
    "4000aea0", //: "transferAndCall(address,uint256,bytes)",
    "23b872dd"} //: "transferFrom(address,address,uint256)"


					

func main() {

	//withSwarmHash := flag.Bool("swarm", true, "solc adds a reference to the Swarm API description to the generated bytecode, if this flag is set it removes this reference before analysis")
	//ctorMode := flag.Bool("ctor", false, "Indicates that the provided bytecode has construction(ctor) code included. (needs to be analyzed seperatly)")
	//ctorIgnore := flag.Bool("ctorIgnore", false, "Do not analyze ctor")
	jlt := true
	//logging := &jlt //flag.Bool("log", false, "print logging output")
	json := &jlt //flag.Bool("json", false, "output json")

	flag.Parse()

	//if !*logging {
	log.SetOutput(ioutil.Discard)
	//}

	hexdata, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		panic(fmt.Sprintf("Could not read from stdin: %v", err))
	}

	bytecodeLength := uint64(hex.DecodedLen(len(hexdata)))
	bytecode := make([]byte, bytecodeLength)

	hex.Decode(bytecode, hexdata)

	// detect swarm hash and remove it from bytecode, see http://solidity.readthedocs.io/en/latest/miscellaneous.html?highlight=swarm#encoding-of-the-metadata-hash-in-the-bytecode
	if bytecode[bytecodeLength-1] == swarmHashProgramTrailer[1] &&
		bytecode[bytecodeLength-2] == swarmHashProgramTrailer[0] &&
		bytecode[bytecodeLength-43] == swarmHashHeader[0] &&
		bytecode[bytecodeLength-42] == swarmHashHeader[1] {
		bytecodeLength -= swarmHashLength // remove swarm part
	}

	program := evmdis.NewProgram(bytecode[:bytecodeLength])
	AnalyzeProgram(program)

	//if *ctorMode {
	var codeEntryPoint = FindNextCodeEntryPoint(program)

	if (*json) {
		fmt.Println("[")
	}

	if codeEntryPoint == 0 {

		PrintAnalysisResult(program, *json)

	} else if codeEntryPoint >= bytecodeLength {
		panic("code entrypoint outside of currently available code")
	} else {

		//ctor := evmdis.NewProgram(bytecode[:codeEntryPoint])
		code := evmdis.NewProgram(bytecode[codeEntryPoint:bytecodeLength])

/*		AnalyzeProgram(ctor)
		if(!*json) { fmt.Println("# Constructor part -------------------------") }
		PrintAnalysisResult(ctor, *json)*/

		AnalyzeProgram(code)
		if(!*json) { fmt.Println("# Code part -------------------------") }
		PrintAnalysisResult(code, *json)
	}

	if (*json) {
		fmt.Println("]")
	}

/*
	} else {
		PrintAnalysisResult(program, *json)
	}*/
}

func FindNextCodeEntryPoint(program *evmdis.Program) uint64 {
	var lastPos uint64 = 0
	for _, block := range program.Blocks {
		for _, instruction := range block.Instructions {
			if instruction.Op == evmdis.CODECOPY {
				var expression evmdis.Expression

				instruction.Annotations.Get(&expression)

				arg := expression.(*evmdis.InstructionExpression).Arguments[1].Eval()

				if arg != nil {
					lastPos = arg.Uint64()
				}
			}
		}
	}
	return lastPos
}

func hasInterface(prog *evmdis.Program, ifs []string) int {
	var methSig []*big.Int
	for _, block := range prog.Blocks {
		for _, inst := range block.Instructions {
			if inst.Op == evmdis.PUSH4 {

				methSig = append(methSig, inst.Arg)
				//fmt.Println(toHexInt(inst.Arg))
			}
		}
	}

	var match = 0
	for _, sig := range ifs {
		var sigi, err = strconv.ParseInt(sig,16,64)
		if err != nil {
			panic(fmt.Sprintf("parser Error: %v", err))
		}

		if hasSig(methSig, big.NewInt(sigi)) {
			match+=1	
		} 
	}

	//fmt.Printf("% x", sha3.Sum([]byte("allowance(address,address)")))
	return match

}

 func hasSig(list []*big.Int, str *big.Int) bool {
 	for _, v := range list {
 		if v.Cmp(str) == 0 {
 			return true
 		}
 	}
 	return false
 }

func toHexInt(n *big.Int) string {
    return fmt.Sprintf("%x", n) // or %X or upper case
}

func PrintAnalysisResult(program *evmdis.Program, json bool) {

	if(json) {
		
		
		fmt.Println("{")
		fmt.Println("\"name\":\"ERC20\",")
		fmt.Println(fmt.Sprintf("\"count\":%v,", len(ERC20)))
		fmt.Println(fmt.Sprintf("\"hit\":%v,", hasInterface(program, ERC20[:])))
		fmt.Println(fmt.Sprintf("\"is\":%v",len(ERC20) == hasInterface(program, ERC20[:])))
		fmt.Println("}")

		fmt.Print(",")

		fmt.Println("{")
		fmt.Println("\"name\":\"ERC223\",")
		fmt.Println(fmt.Sprintf("\"count\":%v,", len(ERC223)))
		fmt.Println(fmt.Sprintf("\"hit\":%v,", hasInterface(program, ERC223[:])))
		fmt.Println(fmt.Sprintf("\"is\":%v",len(ERC223) == hasInterface(program, ERC223[:])))
		fmt.Println("}")

		fmt.Print(",")

		fmt.Println("{")
		fmt.Println("\"name\":\"ERC677\",")
		fmt.Println(fmt.Sprintf("\"count\":%v,", len(ERC677)))
		fmt.Println(fmt.Sprintf("\"hit\":%v,", hasInterface(program, ERC677[:])))
		fmt.Println(fmt.Sprintf("\"is\":%v",len(ERC677) == hasInterface(program, ERC677[:])))
		fmt.Println("}")

		
	} else {
		fmt.Println("ERC20:")
		fmt.Println(hasInterface(program, ERC20[:]) == len(ERC20))
		fmt.Println("ERC223:")
		fmt.Println(hasInterface(program, ERC223[:]) == len(ERC223))
		fmt.Println("ERC677:")
		fmt.Println(hasInterface(program, ERC677[:]) == len(ERC677))
	}
/*	for _, block := range program.Blocks {
		offset := block.Offset

		// Print out the jump label for the block, if there is one
		var label *evmdis.JumpLabel
		block.Annotations.Get(&label)
		if label != nil {
			fmt.Printf("%v\n", label)
		}

		// Print out the stack prestate for this block
		var reaching evmdis.ReachingDefinition
		block.Annotations.Get(&reaching)
		fmt.Printf("# Stack: %v\n", reaching)

		for _, instruction := range block.Instructions {
			var expression evmdis.Expression
			instruction.Annotations.Get(&expression)

			if expression != nil {
				if instruction.Op.StackWrites() == 1 && !instruction.Op.IsDup() {
					fmt.Printf("0x%X\tPUSH(%v)\n", offset, expression)
				} else {
					fmt.Printf("0x%X\t%v\n", offset, expression)
				}
			}
			offset += instruction.Op.OperandSize() + 1
		}
		fmt.Printf("\n")
	}*/
}

func AnalyzeProgram(program *evmdis.Program) {	
	if err := evmdis.PerformReachingAnalysis(program); err != nil {
		panic(fmt.Sprintf("Error performing reaching analysis: %v", err))
	}
	evmdis.PerformReachesAnalysis(program)
	evmdis.CreateLabels(program)
	if err := evmdis.BuildExpressions(program); err != nil {
		panic(fmt.Sprintf("Error building expressions: %v", err))
	}
}
