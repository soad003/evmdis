package main

import (
	"encoding/hex"
	"flag"
	"fmt"
	"github.com/soad003/evmdis"
	"io/ioutil"
	"log"
	"os"
	"math/big"
	"encoding/json"
)

const swarmHashLength = 43

var swarmHashProgramTrailer = [...]byte{0x00, 0x29}
var swarmHashHeader = [...]byte{0xa1, 0x65}

func main() {

	withSwarmHash := flag.Bool("swarm", true, "solc adds a reference to the Swarm API description to the generated bytecode, if this flag is set it removes this reference before analysis")
	ctorMode := flag.Bool("ctor", false, "Indicates that the provided bytecode has construction(ctor) code included. (needs to be analyzed seperatly)")
	logging := flag.Bool("log", false, "print logging output")
	asJson := flag.Bool("json", false, "generate JSON output, when possible")

	calls := false
	printSwarm := false
	printParams := false
	//calls := flag.Bool("calls", false, "print hardcoded/constant addresses that are called")
	//printSwarm := flag.Bool("printSwarm", false, "prints swarm hash if found, only useful if swarm is set")
	//printParams := flag.Bool("printParams", false, "prints params if found")

	output := flag.String("output", "asm", "defines the output expected { asm | swarmHash | params | calls } (default asm)")

	flag.Parse()

	switch *output {
		case "asm":
		case "swarmHash":
			printSwarm = true
		case "params":
			printParams = true
		case "calls":
			calls = true
		default:
			flag.Usage()
	}

	if !*logging {
		log.SetOutput(ioutil.Discard)
	}

	hexdata, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		panic(fmt.Sprintf("Could not read from stdin: %v", err))
	}

	bytecodeLength := uint64(hex.DecodedLen(len(hexdata)))
	bytecode := make([]byte, bytecodeLength)

	hex.Decode(bytecode, hexdata)
	
	if *ctorMode {
		program := evmdis.NewProgram(bytecode)
		AnalyzeProgram(program, nil, false)
		var codeEntryPoint, paramStart = FindNextCodeEntryPoint(program)

		log.Printf("code entrypoint at %v, param begin at %v\n", codeEntryPoint, paramStart)

		if codeEntryPoint == 0 {
			panic("no code entrypoint found in ctor")
		} else if codeEntryPoint >= bytecodeLength {
			panic("code entrypoint outside of currently available code")
		}
		if paramStart == 0 {
			log.Println("no param marker found")
			paramStart = bytecodeLength
		}

		ctor := evmdis.NewProgram(bytecode[:codeEntryPoint])

		bytecode_code := HandleSwarm(bytecode[codeEntryPoint:paramStart], printSwarm, *withSwarmHash, *asJson)

		code := evmdis.NewProgram(bytecode_code)
		
		if paramStart != 0 && paramStart < bytecodeLength && printParams {
			PrintParams(bytecode[paramStart: bytecodeLength],*asJson)
			os.Exit(0)
		}

		AnalyzeProgram(ctor, nil, calls)
		AnalyzeProgram(code, ctor, calls)

		if !*asJson {
			fmt.Println("// # Constructor part -------------------------")
		}	else {
			fmt.Print("{ \"ctor\": ")
		}
		PrintAnalysisResult(ctor, calls, *asJson)
		if *asJson {
			fmt.Print(",")
		}
		
		if !*asJson {
			fmt.Println("// # Code part -------------------------")
		} else {
			fmt.Print("\"code\": ")
		}
		PrintAnalysisResult(code, calls, *asJson)
		if *asJson {
			fmt.Print("}")
		}

	} else {
		bytecode_new := HandleSwarm(bytecode, printSwarm, *withSwarmHash, *asJson)
		program := evmdis.NewProgram(bytecode_new)
		AnalyzeProgram(program, nil, calls)
		PrintAnalysisResult(program, calls, *asJson)
	}
}

func HandleSwarm(bytecode []byte, printSwarm bool, withSwarmHash bool, asJson bool) []byte {
	bytecode_new, hash := ExtractSwarm(bytecode, withSwarmHash)
	if printSwarm {
		PrintSwarm(hash, asJson)
		os.Exit(0)
	}
	return bytecode_new
}

func PrintParams(params []byte, asJson bool) {
	if len(params) % 32 != 0 {
		panic("params length must be multiple of 32")
	}
	if asJson {
		params_data := make([]*string, 0)
		for i := 0; i < len(params); i=i+32 {
			chunk :=  fmt.Sprintf("%X", params[i:i+32])
			params_data = append(params_data, &chunk)
		}
		data := struct {
						    ParamBlob string `json:"paramBlob"`
						    Params []*string `json:"params"`
						}{
						    fmt.Sprintf("%X", params),
						    params_data,
						}
		r, _ := json.MarshalIndent(data, "", "    ")
		fmt.Println(string(r))
	} else {
		fmt.Print(hex.Dump(params))	
	}
}

func ExtractSwarm(bytecode []byte, withSwarmHash bool) ([]byte, string) {
	bytecodeLength := len(bytecode)
	// detect swarm hash and remove it from bytecode, see http://solidity.readthedocs.io/en/latest/miscellaneous.html?highlight=swarm#encoding-of-the-metadata-hash-in-the-bytecode
	if bytecode[bytecodeLength-1] == swarmHashProgramTrailer[1] &&
		bytecode[bytecodeLength-2] == swarmHashProgramTrailer[0] &&
		bytecode[bytecodeLength-43] == swarmHashHeader[0] &&
		bytecode[bytecodeLength-42] == swarmHashHeader[1] &&
		(withSwarmHash) {

		hashstr := hex.EncodeToString(bytecode[bytecodeLength-34:bytecodeLength-2])

		return bytecode[:bytecodeLength-swarmHashLength], hashstr // remove swarm part

	}
	return bytecode, ""
}

func PrintSwarm(hashstr string, asJson bool) {
	if !asJson {
		fmt.Printf("%v\n", hashstr)
	} else {
		data := struct {
						    SwarmHash string `json:"swarmHash"`
						}{
						    hashstr,
						}
		r, _ := json.MarshalIndent(data, "", "    ")
		fmt.Println(string(r))
	}
}

// first code copy usually the start of params used by constructor
// last code copy in ctor is start of params for ctor
func FindNextCodeEntryPoint(program *evmdis.Program) (uint64, uint64) {
	var lastPos uint64 = 0
	var firstPos uint64 = 0
	for _, block := range program.Blocks {
		for _, instruction := range block.Instructions {
			if instruction.Op == evmdis.CODECOPY {
				var expression evmdis.Expression

				instruction.Annotations.Get(&expression)

				instExpr, ok := expression.(*evmdis.InstructionExpression)
				var arg *big.Int
				if ok {
					arg = instExpr.Arguments[1].Eval()
				} else {
					log.Printf("CODECOPY arg not InstExpr: %v\n", expression)
				}

				if firstPos == 0 &&  arg != nil {
					firstPos = arg.Uint64()
				}

				if arg != nil {
					lastPos = arg.Uint64()
				}
			}
		}
	}
	if lastPos == firstPos {
		firstPos =0
	}
	return lastPos, firstPos
}

func AnalyzeProgram(program *evmdis.Program, ctor *evmdis.Program, calls bool) {
	if err := evmdis.PerformReachingAnalysis(program); err != nil {
		panic(fmt.Sprintf("Error performing reaching analysis: %v", err))
	}
	evmdis.PerformReachesAnalysis(program)
	evmdis.CreateLabels(program)
	if err := evmdis.BuildExpressions(program); err != nil {
		panic(fmt.Sprintf("Error building expressions: %v", err))
	}

	if calls {
			evmdis.AnnotateCallsWithConstantAddresses(program)
			evmdis.AnnotateSSTOREsWithConstantValues(program)
			evmdis.ResolveSLOADWithConstructorConstants(program, ctor)
	}
}


func PrintAnalysisResult(program *evmdis.Program, calls bool, asJson bool) {
	if calls {
		jsondata := make([]*evmdis.CallOnAddressOut, 0)
		for _, block := range program.Blocks {
			for _, instruction := range block.Instructions {

				var sto *evmdis.StoreOn

				instruction.Annotations.Get(&sto)

				if sto != nil{
					log.Println(sto)
				}

				var call *evmdis.CallOnAddress

				instruction.Annotations.Get(&call)

				if call != nil && asJson {
					jsondata = append(jsondata, call.ToOutput())
					log.Println(call)
				} else if call != nil{
					fmt.Println(call)
				}
			}
		}

		if asJson {
			r, _ := json.MarshalIndent(jsondata, "", "    ")
			fmt.Print(string(r))
		}
	} else {
		if asJson {
			log.Println("json flag not supported without calls flag")
		}
		PrintHighLevelAsm(program)
	}	
}

func PrintHighLevelAsm(program *evmdis.Program) {
	for _, block := range program.Blocks {
		offset := block.Offset

		// Print out the jump label for the block, if there is one
		var label *evmdis.JumpLabel
		block.Annotations.Get(&label)
		if label != nil {
			fmt.Printf("%v\n", label)
		}

		// Print out the stack prestate for this block
		var reaching evmdis.ReachingDefinition
		block.Annotations.Get(&reaching)
		fmt.Printf("# Stack: %v\n", reaching)

		for _, instruction := range block.Instructions {
			var expression evmdis.Expression
			instruction.Annotations.Get(&expression)

			if expression != nil {
				if instruction.Op.StackWrites() == 1 && !instruction.Op.IsDup() {
					fmt.Printf("0x%X\tPUSH(%v)\n", offset, expression)
				} else {
					fmt.Printf("0x%X\t%v\n", offset, expression)
				}
			}
			offset += instruction.Op.OperandSize() + 1
		}
		fmt.Printf("\n")
	}
}

