package main

import (
	"encoding/hex"
	"fmt"
	"github.com/soad003/evmdis"
	"io/ioutil"
	"log"
	"os"
	"encoding/json"
	"math/big"
)

func main() {

	/*withSwarmHash := flag.Bool("swarm", true, "solc adds a reference to the Swarm API description to the generated bytecode, if this flag is set it removes this reference before analysis")
	ctorMode := flag.Bool("ctor", false, "Indicates that the provided bytecode has construction(ctor) code included. (needs to be analyzed seperatly)")
	logging := flag.Bool("log", false, "print logging output")
	asJson := flag.Bool("json", false, "generate JSON output, when possible")

	calls := false
	printSwarm := false
	printParams := false
	dump := false
	//calls := flag.Bool("calls", false, "print hardcoded/constant addresses that are called")
	//printSwarm := flag.Bool("printSwarm", false, "prints swarm hash if found, only useful if swarm is set")
	//printParams := flag.Bool("printParams", false, "prints params if found")

	output := flag.String("output", "asm", "defines the output expected { asm | swarmHash | params | calls | dump } (default asm)")

	flag.Parse()

	switch *output {
		case "asm":
		case "swarmHash":
			printSwarm = true
		case "params":
			printParams = true
		case "calls":
			calls = true
		case "dump":
			dump=true
		default:
			flag.Usage()
	}*/

	//if !*logging {
		log.SetOutput(ioutil.Discard)
	//}

	hexdata, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		panic(fmt.Sprintf("Could not read from stdin: %v", err))
	}

	bytecodeLength := uint64(hex.DecodedLen(len(hexdata)))
	bytecode := make([]byte, bytecodeLength)

	hex.Decode(bytecode, hexdata)

	/*if dump {*/
	program := evmdis.NewProgram(bytecode)
	pushes := make([]string, 0)
	var maskingAddress = big.NewInt(0)
		maskingAddress.SetString("ffffffffffffffffffffffffffffffffffffffff", 16)
	for _, block := range program.Blocks {
		for _, instruction := range block.Instructions {
			if instruction.Op == evmdis.PUSH20 && instruction.Arg.Cmp(maskingAddress) != 0 {
				pushes = append(pushes, fmt.Sprintf("0x%x", instruction.Arg))
			}
		}
	}
	b, _ := json.Marshal(pushes)
	fmt.Println(string(b))
	os.Exit(0)
	// }
	

}

